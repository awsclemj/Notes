- [Data Protection](#data-protection)
  - [KMS Overview](#kms-overview)
    - [Customer Master Keys](#customer-master-keys)
      - [Encryption Context](#encryption-context)
      - [Grants](#grants)
    - [Importing Key Material](#importing-key-material)
    - [Service-level Integration](#service-level-integration)
      - [EBS](#ebs)
      - [DynamoDB](#dynamodb)
      - [RDS](#rds)
      - [S3](#s3)
  - [CloudHSM Overview](#cloudhsm-overview)
  - [S3 SSE-C](#s3-sse-c)
  - [Encryption SDK](#encryption-sdk)

# Data Protection
Notes taken via Linux Academy

## KMS Overview
* Uses FIPS 140-2 level 2 compliant hardware security modules (HSMs)
* Can be used with most AWS services that support encryption 
* Primary purpose: generate and manage **customer master keys (CMKs)**
  * Key material can be generated or imported
  * Can never be exported from KMS
  * Can decrypt/encrypt data up to 4 KB

### Customer Master Keys
* Access controlled by key policies (resource-based policy)
  * By default, only root user can administer/perform encryption operations; identity policies can be applied to users/groups to access the key
  * Alternatively, you can override the default key policy and reference allowed principals and permissions
  * CMKs become locked if the policy is cleared out
* Can be AWS-managed or customer-managed
  * AWS-managed keys do not have configurable options. Automatically rotated every **three years**
  * Customer-managed have many configuration options
    * Polcies
    * Alias
    * Tags
    * Automatic key rotation (every **365 days**)
    * Manual rotation - create new key and change key alias
* Can create an alias as shorthand to point at a key ID (must be regionally unique)
* Used to generate **data encryption keys (DEKs)**
  * Ex.: S3 generates a DEK for every object it encrypts using the CMK
* `GenerateDataKey` - API call that produces an encrypted and plaintext DEK (Base64 encoded)
  * Plaintext version is used to encrypt then discarded. Encrypted DEK is stored alongside ciphertext
* `Decrypt` - API call to decrypt the DEK. The plaintext DEK is returned and used to decrypt ciphertext
  * Does not need to know the CMK; this information is stored with the encrypted DEK
* CMKs are a wrapper for one or more backing keys. When you run `Encrypt` operations with a CMK, you're using the most recent backing key.
  * CMKs know which backing key was used to encrypt an object; old backing keys are automatically used for `Decrypt` operations.
* `ReEncrypt` - API to re-encrypt ciphertext using a different CMK; ciphertext passed to KMS which decrypts and re-encrypts using new key.
  * Gives you the ability to have administrators re-encrypt data without seeing the decrypted plaintext

#### Encryption Context
* Key/value pairs passed to KMS for encryption; same K/V pairs must be passed for decrypt operations
* Don't use sensitive values

#### Grants
* Allows an entity to have short-term ability to use a key
* Similar in concept to presigned URLs

### Importing Key Material
* Use cases:
  * If you want to prove your key material meets a standard of entropy requirements
  * To use key material generated by your own infrastructure
  * Set expiration times or manually delete CMKs
  * Keep a copy of your key material outside of AWS

### Service-level Integration
* KMS responsibility ends with the CMKs or the DEKs they generate
* The service is responsible for how these data keys are used

#### EBS
* Calls `GenerateDataKeyWithoutPlantext` API and stores the encrypted DEK as metadata 
* Hypervisor on EC2 instance passes the encrypted data key to KMS; KMS responds with plaintext DEK
  * Hypervisor stores the plaintext key in memory
  * Hypervisor performs encrypt/decrypt operations on I/O with volume 

#### DynamoDB
* Dynamo uses KMS to create a default CMK
* When a table is set to be encrypted, the default CMK is used to create a DEK unique to the table
  * Called a **table key**
  * Managed by DDB and stored in encrypted form
* Every item in a table is encrypted with a unique DEK that is encrypted by the table key and stored with the data
* Table keys are cached in plaintext up to 12 hours 
  * However, requests are made to KMS every five minutes of table key inactivity to see if permissions have changed

#### RDS
* RDS utilizes EBS for encryption, therefore the concept here is the same

#### S3
* Every object is encrypted with a unique plaintext DEK generated by a CMK
* A ciphertext DEK is stored alongside the object as metadata 
* Every version of every object can use its own DEK

## CloudHSM Overview
* FIPS 140-2 level 3 compliant 
* Dedicated HSM that runs in your VPC (single-tenant hardware)
* AWS maintains hardware, but has no access to the cryptographic component
  * Support cannot restore your keys
* Interaction is via industry-standard APIs, not AWS APIs
  * PKCS #11, Java Cryptography Extensions, Microsoft CryptoNG
  * Does not integrate directly with AWS services
* Keys can be exported to other HSMs, including on-prem
* Applications using the HSM can be outside the VPC

## S3 SSE-C
* Feature of S3 SSE which allows a customer to handle their own key lifecycle rather than KMS
* `x-amz-server-side-encryption-customer-key` - customer can use this header to provide the DEK
  * S3 doesn't store the key, but an HMAC value to validate the key used for the object
* `x-amz-server-side-encryption-customer-key-MD5` - used for key validation
* `x-amz-server-side-encryption-customer-algorithm` - used to inform S3 that a customer managed key will be used for PutObject
* Cannot be used in CRR

## Encryption SDK
* Encryption library that makes it easy to work with AWS KMS and other HSMs. 
* Adheres to security best practices to standardize encryption/decryption of DEKs as well as caching DEKs.
  * Caching keys helps reduce requests to the KMS API